# SPDX-License-Identifier: GPL-2.0+
# Copyright 2020 Google LLC
# Written by Simon Glass <sjg@chromium.org>

from enum import Enum, auto
import re
import time

import collections
from labman.part import Part
from labman import work

class Part_usbboot(Part):
    """A tegra RCM (Remote Controller and Monitoring) connection

    This allows downloading software to the DUT oevr USB using the boot ROM

    Properties:
        _serial: Serial number of the Ykusb
        _symlink: Symlink to the device
    """
    class Method(Enum):
        # No method available (sending will not work)
        NONE = auto()
        # Reset while pressing the recovery button
        RECOVERY_RESET = auto()
        # Reset while the MMC is not available to the DUT
        BOOTDEV_TS_RESET = auto()
        # Power cycle while pressing the recovery button plus another button
        RECOVERY_POWER_EXTRA = auto()

    def __init__(self):
        super().__init__()
        self.vendor = None
        self.product = None
        self.recovery_method = self.Method.NONE

    def load(self, yam):
        """Load the object from a yaml definition

        Args:
            yam (dict): Yaml definition
        """
        self.load_usb_port(yam)
        self._symlink = yam.get('symlink')
        if self._symlink is None:
            self.raise_self("Missing symlink")
        self.loadaddr = yam.get('loadaddr')
        self.retries = yam.get('retries', 2)

    def raise_self(self, msg):
        """Raise an error related to this USB connection

        Args:
            msg (str): Message to report

        Raises:
            ValueError: always
        """
        raise ValueError('%s: %s' % (str(self), msg))

    def get_detail(self, port=None):
        return '%s' % self._symlink

    def set_recovery_method(self, method):
        self.recovery_method = method

    def check(self):
        dut = self.find_dut_by_send_device()
        try:
            msg = dut.reset_to_recovery(self._symlink, retries=self.retries)
            good = not msg
        except ValueError as e:
            good = False
            msg = str(e)
        return work.CheckResult(self, good, msg)

    def emit(self):
        emit_list = []
        emit_list.append(self.emit_udev())
        return emit_list

    def emit_udev(self):
        template = '''# {name}
ACTION=="add|bind" \\
, SUBSYSTEMS=="usb" \\
, KERNELS=="{kernel_phys_port}" \\
, ATTR{{idVendor}}=="{vendor}" \\
, ATTR{{idProduct}}=="{product}" \\
, SYMLINK+="{symlink}" \\
, MODE="0666"


'''.splitlines()
        vals = {
            'name': str(self),
            'kernel_phys_port': self._kernel_phys_port,
            'symlink': self._symlink,
            'vendor': '%04x' % self.vendor
            }
        if self.product:
            vals['product'] = '%04x' % self.product
        else:
            regex = re.compile('{idProduct}')
            template = [line for line in template if not regex.search(line)]

        out = '\n'.join(template).format(**vals)
        return work.EmitResult(self, 'udev/99-labman-usbboot.rules', out,
                               '# Generated by labman')

    def get_py_class_vars(self, part_ref):
        out = {
            'send_device': '/dev/%s' % self._symlink,
            'usbboot_loadaddr': self.loadaddr,
            'usbboot_port': self._kernel_phys_port,
            }
        return out
