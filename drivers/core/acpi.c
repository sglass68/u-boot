// SPDX-License-Identifier: GPL-2.0+
/*
 * Core driver model support for ACPI table generation
 *
 * Copyright 2019 Google LLC
 * Written by Simon Glass <sjg@chromium.org>
 */

#define LOG_CATEOGRY	LOGC_ACPI

#include <common.h>
#include <dm.h>
#include <dm/acpi.h>
#include <dm/device-internal.h>
#include <dm/root.h>

#define MAX_ITEMS	100

/* Type of table that we collected */
enum gen_type_t {
	TYPE_SSDT,
};

/**
 * struct acpi_item - Holds info about ACPI data generated by a driver method
 *
 * @dev: Device that generated this data
 * @type: Table type it refers to
 * @buf: Buffer containing the data
 * @size: Size of the data in bytes
 */
struct acpi_item {
	struct udevice *dev;
	enum gen_type_t type;
	char *buf;
	int size;
};

/* List of ACPI items collected */
static struct acpi_item acpi_item[MAX_ITEMS];
static int item_count;

int acpi_return_name(char *out_name, const char *name)
{
	strcpy(out_name, name);

	return 0;
}

int acpi_get_name(const struct udevice *dev, char *out_name)
{
	struct acpi_ops *aops;

	aops = device_get_acpi_ops(dev);
	if (aops && aops->get_name)
		return aops->get_name(dev, out_name);

	return -ENOSYS;
}

/**
 * acpi_add_item() - Add a new item to the list of data collected
 *
 * @ctx: ACPI context
 * @dev: Device that generated the data
 * @type: Table type it refers to
 * @start: The start of the data (the end is obtained from ctx->current)
 * @return 0 if OK, -ENOSPC if too many items, -ENOMEM if out of memory
 */
static int acpi_add_item(struct acpi_ctx *ctx, struct udevice *dev,
			 enum gen_type_t type, void *start)
{
	struct acpi_item *item;
	void *end = ctx->current;

	if (item_count == MAX_ITEMS) {
		log_err("Too many items\n");
		return log_msg_ret("mem", -ENOSPC);
	}

	item = &acpi_item[item_count];
	item->dev = dev;
	item->type = type;
	item->size = end - start;
	if (!item->size)
		return 0;
	item->buf = malloc(item->size);
	if (!item->buf)
		return log_msg_ret("mem", -ENOMEM);
	memcpy(item->buf, start, item->size);
	item_count++;
	log_debug("* %s: Added type %d, %p, size %x\n", dev->name, type, start,
	       item->size);

	return 0;
}

int _acpi_fill_ssdt(struct acpi_ctx *ctx, struct udevice *parent)
{
	struct acpi_ops *aops;
	struct udevice *dev;
	int ret;

	aops = device_get_acpi_ops(parent);
	if (aops && aops->fill_ssdt) {
		void *start = ctx->current;

		log_debug("\n- %s %p\n", parent->name,
			  aops->fill_ssdt);
		ret = device_ofdata_to_platdata(parent);
		if (ret)
			return log_msg_ret("ofdata", ret);
		ret = aops->fill_ssdt(parent, ctx);
		if (ret)
			return log_msg_ret("ssdt", ret);

		/* Add the item to the internal list */
		ret = acpi_add_item(ctx, parent, TYPE_SSDT, start);
		if (ret)
			return log_msg_ret("add", ret);
	}
	device_foreach_child(dev, parent) {
		ret = _acpi_fill_ssdt(ctx, dev);
		if (ret)
			return log_msg_ret("recurse", ret);
	}

	return 0;
}

int acpi_fill_ssdt(struct acpi_ctx *ctx)
{
	int ret;

	log_debug("Writing SSDT tables\n");
	ret = _acpi_fill_ssdt(ctx, dm_root());
	log_debug("Writing SSDT finished, err=%d\n", ret);

	return ret;
}

int _acpi_write_dev_tables(struct acpi_ctx *ctx, const struct udevice *parent)
{
	struct acpi_ops *aops;
	struct udevice *dev;
	int ret;

	aops = device_get_acpi_ops(parent);
	if (aops && aops->write_tables) {
		log_debug("- %s\n", parent->name);
		ret = aops->write_tables(parent, ctx);
		if (ret)
			return ret;
	}
	device_foreach_child(dev, parent) {
		ret = _acpi_write_dev_tables(ctx, dev);
		if (ret)
			return ret;
	}

	return 0;
}

int acpi_write_dev_tables(struct acpi_ctx *ctx)
{
	int ret;

	log_debug("Writing device tables\n");
	ret = _acpi_write_dev_tables(ctx, dm_root());
	log_debug("Writing finished, err=%d\n", ret);

	return ret;
}
